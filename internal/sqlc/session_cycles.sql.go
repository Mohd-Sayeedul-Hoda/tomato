// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: session_cycles.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createSessionCycle = `-- name: CreateSessionCycle :one
INSERT INTO session_cycles(session_id, type, start_time, status, timer_profile_id)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id
`

type CreateSessionCycleParams struct {
	SessionID      int64
	Type           sql.NullString
	StartTime      sql.NullTime
	Status         sql.NullString
	TimerProfileID int64
}

func (q *Queries) CreateSessionCycle(ctx context.Context, arg CreateSessionCycleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createSessionCycle,
		arg.SessionID,
		arg.Type,
		arg.StartTime,
		arg.Status,
		arg.TimerProfileID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteSessionCycle = `-- name: DeleteSessionCycle :exec
DELETE FROM session_cycles
WHERE id = ?1
`

func (q *Queries) DeleteSessionCycle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSessionCycle, id)
	return err
}

const getSessionCycleByID = `-- name: GetSessionCycleByID :one
SELECT id, session_id, timer_profile_id, type, created_at, start_time, end_time, duration, status FROM session_cycles
WHERE id = ?1
`

func (q *Queries) GetSessionCycleByID(ctx context.Context, id int64) (SessionCycle, error) {
	row := q.db.QueryRowContext(ctx, getSessionCycleByID, id)
	var i SessionCycle
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.TimerProfileID,
		&i.Type,
		&i.CreatedAt,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Status,
	)
	return i, err
}

const getSessionCycleByStatusWithMetadata = `-- name: GetSessionCycleByStatusWithMetadata :many
SELECT
    sc.id,
    sc.session_id,
    sc.type,
    sc.created_at,
    sc.start_time,
    sc.end_time,
    sc.duration,
    sc.status,
    tp.work_duration as work_duration,
    tp.break_duration as break_duration,
    tp.long_break_duration as long_break_duration,
    tp.long_break_cycle as long_break_cycle
FROM
    session_cycles AS sc
INNER JOIN
    sessions AS s ON sc.session_id = s.id
LEFT JOIN
    time_profiles AS tp ON sc.timer_profile_id = tp.id
WHERE
    sc.status = ?1
`

type GetSessionCycleByStatusWithMetadataRow struct {
	ID                int64
	SessionID         int64
	Type              sql.NullString
	CreatedAt         sql.NullTime
	StartTime         sql.NullTime
	EndTime           sql.NullTime
	Duration          sql.NullInt64
	Status            sql.NullString
	WorkDuration      sql.NullInt64
	BreakDuration     sql.NullInt64
	LongBreakDuration sql.NullInt64
	LongBreakCycle    sql.NullInt64
}

func (q *Queries) GetSessionCycleByStatusWithMetadata(ctx context.Context, status sql.NullString) ([]GetSessionCycleByStatusWithMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionCycleByStatusWithMetadata, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionCycleByStatusWithMetadataRow
	for rows.Next() {
		var i GetSessionCycleByStatusWithMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Type,
			&i.CreatedAt,
			&i.StartTime,
			&i.EndTime,
			&i.Duration,
			&i.Status,
			&i.WorkDuration,
			&i.BreakDuration,
			&i.LongBreakDuration,
			&i.LongBreakCycle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionCycles = `-- name: ListSessionCycles :many
SELECT id, session_id, timer_profile_id, type, created_at, start_time, end_time, duration, status FROM session_cycles
WHERE
  -- Filter by session_id: If NULL, ignore
  (? IS NULL OR session_id = ?)
  AND
  -- Filter by status: If NULL, ignore
  (? IS NULL OR status = ?)
  AND
  -- Filter by type: If NULL, ignore
  (? IS NULL OR type = ?)
ORDER BY created_at DESC
LIMIT ?
`

type ListSessionCyclesParams struct {
	SessionID interface{}
	Status    interface{}
	Type      interface{}
	Limit     int64
}

func (q *Queries) ListSessionCycles(ctx context.Context, arg ListSessionCyclesParams) ([]SessionCycle, error) {
	rows, err := q.db.QueryContext(ctx, listSessionCycles,
		arg.SessionID,
		arg.Status,
		arg.Type,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SessionCycle
	for rows.Next() {
		var i SessionCycle
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.TimerProfileID,
			&i.Type,
			&i.CreatedAt,
			&i.StartTime,
			&i.EndTime,
			&i.Duration,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSessionCycleComplete = `-- name: MarkSessionCycleComplete :exec
UPDATE session_cycles
SET status = ?2, end_time = ?3, duration = ?4
WHERE id = ?1
`

type MarkSessionCycleCompleteParams struct {
	ID       int64
	Status   sql.NullString
	EndTime  sql.NullTime
	Duration sql.NullInt64
}

func (q *Queries) MarkSessionCycleComplete(ctx context.Context, arg MarkSessionCycleCompleteParams) error {
	_, err := q.db.ExecContext(ctx, markSessionCycleComplete,
		arg.ID,
		arg.Status,
		arg.EndTime,
		arg.Duration,
	)
	return err
}

const markSessionCycleCompleted = `-- name: MarkSessionCycleCompleted :exec
UPDATE session_cycles
SET status = 'completed', end_time = CURRENT_TIMESTAMP
WHERE id = ?1
`

func (q *Queries) MarkSessionCycleCompleted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markSessionCycleCompleted, id)
	return err
}

const updateSessionCycleStatus = `-- name: UpdateSessionCycleStatus :exec
UPDATE session_cycles
SET status = ?2
WHERE id = ?1
`

type UpdateSessionCycleStatusParams struct {
	ID     int64
	Status sql.NullString
}

func (q *Queries) UpdateSessionCycleStatus(ctx context.Context, arg UpdateSessionCycleStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionCycleStatus, arg.ID, arg.Status)
	return err
}
